using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System
{   
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// <summary>Интерфейс, призван получить новый экземпляр объекта, минуя Activator.CreateInstance. Использовать совместно с:ICloneable
    /// Вероятно это положительно скажется на производительности вычислений
    /// за счет прямого создания нового экземпляра объекта, минуя рефлексию.
    /// Подвох вот в чом, нельзя использовать генетические методы, так как они не приимают в качестве класса интерфейсы
    /// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// бЛИН ЕЩЕ ОДИН НУЖНЫЙ КОМЕНТАРИЙ
    /// ICloneable + INewEable => Содержат две функции
    /// При этом их реаализация будет содержать 4 функции, так как 2 из них будут возвращать System.Object
    /// А две другие будут возвращать уже конктерно типизированный объект
    /// Если запускаете гллубокое копирование, то будет дергаться та функция которая возвращает конкретизированный объект 
    /// Если у Вас у класса есть интерфейс, то тогда придется 2 из тех четырех функций реализовать и в нем....
    /// </summary>
    public interface INewEable
    {
        /// <summary>Получить новую копию объекта</summary>
        System.Object New();
    }
}