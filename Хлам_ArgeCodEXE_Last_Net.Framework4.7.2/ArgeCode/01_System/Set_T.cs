namespace System
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    ////////////////////////////////////////////////////
    /// <summary>
    /// Генетическое контекстно ориентированное расширение,
    /// добавляет к любому экземпляру объекта следующие функции.
    /// </summary>
    public static class Set_T
    {
        /// <summary>Установка лямбда контекста для экземпляра объекта или конкретного типа</summary>
        /// <typeparam name="T">Генетический тип</typeparam>
        /// <param name="_this">Экземпляра объекта или конкретного типа от которого вызывается текущий лямбда контекст</param>
        /// <param name="x">Вызываемый к исполнению лямбда контекст (лямбда выражение или делегат)</param>
        /// <returns>Возвращает все тот же экземпляр объекта от которого был вызван контекст</returns>
        public static T Set<T>(this T _this, System.Action<T> x) { x(_this); return _this; }
        private class LocalClassForTest 
        {
            public System.Int32 p_Int32 = 6;
            public System.String p_String = "Привет мир";
            
            public override string ToString()=>"<"+this.p_Int32+"><"+ p_String + ">";
        }
        /// <summary>
        ///Пример использования:
        ///System.Set_T.Test();
        /// </summary>
        public static void Test() 
        {
            
            (new LocalClassForTest())
                .Set(a => System.Console.WriteLine(a.ToString()))
                .Set(a => a.p_Int32 =2)
                .Set(a => System.Console.WriteLine(a.ToString()))
                .Set(a =>{
                    a.p_String = "Привет всем";
                    System.Console.WriteLine(a.ToString());
                })
                .ToString()
                .Set(a => System.Console.WriteLine(a))
            ;
            //Необходимая теория:
            //Лямбда выражения, делигаты,
            //патерн функционального программирования "Возвращение с продолжением",
            //патерн функционального программирования "Функции высших порядков".
            //Актуальность:
            //Всего "одна строка программного кода": "public static T Set<T>(this T _this, System.Action<T> x) { x(_this); return _this; }"
            //-Позволяет в C# писать одновременно в функциональном стиле и в объектно ориентированном стиле,
            //перепрыгивая с одного стиля на другой, без потери преимуществ обоих стилей...
            //Этот прием впервые предлагается нами и является сочетанием:
            //контекстно ориентированного программиирования (как функция от экземпляра объекта, которая становится доступна только при вызове соответствующего пространства имен),
            //генетических методы и классы (другими словами обобщения (Generics)). 
            //Эти приемы в документации c# - встречаются по раздельности, но совместное их использование предлагается нами в первые.

            //В языке c# достаточно часто можно найти некоторые вполне пригодные для одиночного использования конкретным образом приемы и механизмы,
            //но при попытке их совместного или более обобщенного использования возникают неимоверно большие трудность, вплоть до того что
            //"В теории должно работать, а на практике не работает ... одни сплошные огорчения!"
            //Как хорошо что это не тот случай...
            //Поиск таких работающих сочетаний - весьма трудозатратное для этого языка дело, так как удача приходит примерно в каждом десятом случае

            //***Скептики могут усомниться в производительности такого программного кода.
            //Отвечу на этот вопрос так.
            //Использование лямбда выражений и стека вызова функций по времени исполнения много меньше чем время отклика пользователя или объемы оптимизационных работ (рефакторинга) на современных проектах.
            //Хронически делается выбор в сторону скорости разработки нежели внутреннего качества и простоты программногоо кода.
            //Эксперименты показали (а их имеет смысл провести)(опыт многоголетнегого использования), что вызов лямбда контекста сравним по времени с операцией преобразования числа в текст и обратно.
            //Рекомендании по повышению бастродействия:
            //Не используйте глубокую степень вложенности лямбда контекстов. Более 6- 8 вложенных друг в друга лямбда выражений вызывают значительное замедление.
            //Данный прием предназначен для использования на нелольшой глубине вложенности в пределах текущей исполняемой функйии.
            //1-3 уровень вложенности, если их более то это повод усомниться в качестве программного кода и начать его рефапкторинг.
            //Всегда можно написать проще.

            //***Скептики могут усомниться в практической пользе этого приема.
            //Ваше право.
            //Факты говорят о следующем:
            //*Занимает меньше места
            //При использовании этого приема не обязательно создавать локальные переменные. Лямбда контекст делает это за нас.
            //Например
            (new LocalClassForTest())
              .Set(a => a.p_Int32 = 9)//Название переменной:а
            ;
            //Короткие названия переменных с компактной (неполной) формой их объвления как входных параметров лямбда выражения значительно сокращает объем программного кода.
            //*Отвязывает программный код от названия переменных
            //Так ли уж ли важно как они называются?
            //При копировании программного кода в виде цепочки вызванных лямбда контекстов нет необходимости менять названия перемнных
            //Названия переменных существуют в виде одной буквы только в пределах лямбда контекста, который к тому же как правило не очень большой.
            //При необходимости никто не мешает Вам сделать следующее:
            (new LocalClassForTest()).Set((LocalClassForTest MyObject) => MyObject.p_Int32 = 2);
            //То есть в ущерб компактности применить объявление входных параметров лямбда выражения в полной форме.
            //*Позволяет писать программные коды "в одну небольшую строчку", вместо половины страници программного кода в классическом императивном стиле.
            //Такой программный код проще один раз увидеть и понять, чем многократно листать несколько страниц программного кода.

            //***Скептики могут усомниться в необходимости этого приема в C#
            //Увы на этот попрос ответит время!!! И это так.
            //Скептики могут упомянуть, что есть функциональный язык F#...
            //У меня к вам встречный вопрос.
            //Много ли проектов написанных на F# вы видели?//В каких из них учавствовали?
            //Какие проекты Вам чаще встречаются? F# или C#?
            //В этом и заключается ответ на Ваш вопрос!)
            //*Во первых проектов и вакансий C# куда больше.
            //Я не отрицаю пользу от существования F#.
            //*Во вторых, процетирую (не дословно, но с совпадением смысла) разработчиков сообщества языка Julia.
            //"""Практика показала, что более живучим оказывается тот язык, который пользоователю дает большую синтаксическую свободу, нежели загоняет их в узкие рамки!!!"""
            //Сейчас больших успехов достигает разработка проекта, если в нем разумно сочетаются больше одного стиля программирования.
            //*В третих, как практика показывает следующее: "Если желаете замусорить язык, тогда создайте ещё одно ключевое слово! И так много раз)".
            //При написании этой библиотеки использовалось минимально возможное колличество ключевых слов и и минимально возможный объем программных кодов, ну или я к этому стремимся.
            //Добавлю, мы предлагаем библиотеку, расширяющую язык C# до полноценного функционального языка программирования. "Все во имя красоты синтаксиса!!!"
            //И зучение этой библиотеки обойдется куда дешевле по времени чем изучение F#.

            //Последний довод.
            //Вспомним про LinQ!!! 
            //Опыт изучения нашей библиотеки и знание LinQ гармонично дополнят друг друга. В C#, как в функциональном языке почти не останется ощутимых синтаксических пробелов.
        }
    }
}